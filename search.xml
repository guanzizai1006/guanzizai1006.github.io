<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[疲劳驾驶项目成果图文展示]]></title>
    <url>%2F%E7%96%B2%E5%8A%B3%E9%A9%BE%E9%A9%B6%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C%E5%9B%BE%E6%96%87%E5%B1%95%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[疲劳驾驶项目成果图片展示这里将之前做的东西上传到这里，以便于自己回顾总结，并提醒自己，要对基本方法进行改进，以达到更好的效果web端图片展示如下： 暂时先补充这些，web端即将上线，届时更新到服务器上，完成在线检测功能。]]></content>
      <categories>
        <category>疲劳驾驶项目成果图文展示</category>
      </categories>
      <tags>
        <tag>图文展示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 和 GitHub 的使用方法汇总]]></title>
    <url>%2FGit%E5%92%8CGitHub%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[categories: Gittags: [Git, Github]参考链接如下 我们需要使用git在本地创建一个相同的项目。&lt;pre&gt; $ makdir ~/hello-world //创建一个项目hello-world $ cd ~/hello-world //打开这个项目 $ git init //初始化 $ touch README $ git add README //更新README文件 $ git commit -m &apos;first commit&apos;//提交更新，并注释信息“first commit” $ git remote add origin git@github.com:defnngj/hello-world.git //连接远程github项目 $ git push -u origin master //将本地项目更新到github项目上去 &lt;/pre&gt; 源文档 &lt;https://www.cnblogs.com/fnng/archive/2011/08/25/2153807.html&gt; Git的诞生Linus Torvalds在1991年创建了开源系统Linux，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！然后，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了。 源文档 &lt;http://www.testclass.net/git/git-github-start/&gt; 更改readme文件！！！第一步尝试失败： &lt;pre&gt; Bruce Lee@Bruce MINGW64 ~/bruce_demo_pack (master) $ vim README Bruce Lee@Bruce MINGW64 ~/bruce_demo_pack (master) $ git push -u origin master Everything up-to-date Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. &lt;/pre&gt; 单独更改了其中的README文件后，直接执行“git push -u origin master”语句，其并不能同步到GitHub网站上去。 Note: 在第一次远程链接某项目时，这一句，必不可少！1$ git remote add origin git@github.com:guanzizai1006/bruce_demo_pack.git 第二次尝试成功： Bruce Lee@Bruce MINGW64 ~/bruce_demo_pack (master) $ git commit -m “用git commit -m 提交更新” [master bffe44a] “用git commit -m 提交更新 1 file changed, 11 insertions(+) 使用此命令， &lt;pre&gt; $ git commit -m &quot;用git commit -m 提交更新&quot; //双引号内是添加的评论内容,成功提交更新，下一步是要push上去！ $ git push -u origin master Bruce Lee@Bruce MINGW64 ~/bruce_demo_pack (master) $ git push -u origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 660 bytes | 660.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To github.com:guanzizai1006/bruce_demo_pack.git 13cf1ed..bffe44a master -&gt; master Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. &lt;/pre&gt; 当本地项目中，新添加了一个 py 文件后，要上传到云端。 $ git add one.py //更新README文件 $ git commit -m 'add the file named one.py' //提交更新，并注释信息“first commit，用以说明本次更新的是啥” 源文档 【当然，这时候可以考虑，要不要远程连接github项目。 $ git remote add origin git@github.com:guanzizai1006/bruce_demo_pack.git 】 $ git push -u origin master //将本地项目更新到github项目上去 克隆到本地。（前期准备阶段）首先，下载安装Git。 其次，通过Git生成本地公钥，并且将公钥添加到GitHub中。 最后，设置仓库人员的用户名和邮箱地址。 用 git clone 命令，克隆到目标路径。（ssh 方式） 或者 （http 方式） 1$ git clone https://github.com/defnngj/project-name “git add” 命令对当前目录下的文件添加跟踪。这个命令后面 加一个 点 . 则意味着路径下的所有文件“git commit” 命令将添加文件提交到本地仓库。“git push” 将本地项目提交到远程仓库GitHub。除第一次下载项目需要通过 “git clone” 将项目克隆到本地外,后续再使用 “git pull” 命令时会直接将更新拉取到本地 $ git pull origin master 源文档 # 命令行，windows进入别的盘符 Bruce Lee@Bruce MINGW64 ~ $ cd /d Git的入门学习和使用。 ————————Linux下安装git 并下载码云仓库—————————————— bruce@bruce-virtual-machine:~$ sudo apt-get install git [sudo] bruce 的密码： 正在读取软件包列表... 完成 正在分析软件包的依赖关系树 正在读取状态信息... 完成 git 已经是最新版 (1:2.7.4-0ubuntu1.4)。 升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 83 个软件包未被升级。 新建本地文件夹 bruce@bruce-virtual-machine:~/桌面$ mkdir face_fatigue_detection 克隆到本地 bruce@bruce-virtual-machine:~/桌面/face_fatigue_detection$ git clone https://gitee.com/thc1234/face_fatigue_detection.git 正克隆到 'face_fatigue_detection'... Username for 'https://gitee.com': guanzizai1006 Password for 'https://Bruce@gitee.com': 克隆完成啦 bruce@bruce-virtual-machine:~/桌面/face_fatigue_detection$ git clone https://gitee.com/thc1234/face_fatigue_detection.git 正克隆到 'face_fatigue_detection'... Username for 'https://gitee.com': guanzizai1006 Password for 'https://guanzizai1006@gitee.com': remote: Enumerating objects: 405, done. remote: Counting objects: 100% (405/405), done. remote: Compressing objects: 100% (398/398), done. remote: Total 405 (delta 196), reused 0 (delta 0) 接收对象中: 100% (405/405), 113.33 MiB | 1.23 MiB/s, 完成. 处理 delta 中: 100% (196/196), 完成. ———————— Git配置 gitee码云———————————————————— 由本地文件夹更新到云端的话，则只要命令行 ./push.sh 则可以完成了。 由云端更新到本地，只需要在本地目录下，执行 git pull 就OK了。 ———————————————————————————————————— 查看当前路径的“完整路径” 新建本地文件夹后，克隆云端内容到本地目录 运行sh文件， sh 文件内容如下： #!/bin/bash git add ./* git commit -m "shell" git push 截图如下]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装opencv2.4.13.6及配置环境]]></title>
    <url>%2Fubuntu16.04%E5%AE%89%E8%A3%85opencv2.4.13.6byBruce%2F</url>
    <content type="text"><![CDATA[categories: ubuntutags: [ubuntu，opencv，安装] 准备阶段官网下载源码包，存到Linux下的“下载”，并解压。bruce@bruce-virtual-machine:~/下载$ unzip opencv-2.4.13.6.zip (第一步)安装编译工具。bruce@bruce-virtual-machine:~$ sudo apt-get install build-essential则会显示以下内容正在读取软件包列表… 完成正在分析软件包的依赖关系树正在读取状态信息… 完成build-essential 已经是最新版 (12.1ubuntu2)。升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 198 个软件包未被升级。 (第二步)安装依赖包，主要参考了如下2个文档，都包含了必备的包。https://blog.csdn.net/maxujian3893/article/details/64125988（较少安装包）下面依赖关系主要是为了能够支持读写图片以及视频sudo apt-get install libgtk2.0-dev libavcodec-dev libavformat-dev libtiff4-dev（独有，提示已经被废弃，bruce并未安装。在使用pyth Ubuntu下叫做python-dev，CentOS下叫做python-devel，标记一下。） libswscale-dev libjasper-dev安装cmake，请输入命令 sudo apt-get install cmake安装pkg-config。请输入命令： sudo apt-get install pkg-config 它是一个提供从源代码中编译软件时查询已安装的库时使用的统一接口的计算机软件。Ps.下图是查询Linux是否安装了某个包的方法 https://blog.csdn.net/u011557212/article/details/54706966?utm_source=itdadao&amp;utm_medium=referral （较多安装包）安装依赖包sudo apt-get install cmake git libgtk2.0-dev（失败，难道16.04要换成3.0而不是2.0？） pkg-config libavcodec-dev libavformat-dev libswscale-dev安装可选包sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 源码+编译工具安装+依赖包的安装 三者全部搞定之后，接下来就是要编译啦！ a.首先进入当前解压的源码包opencv所在目录opencv2.4.13.6 。使用的是cd命令或者是鼠标直接点击文件夹。 b.创建一个新的文件夹。输入指令： mkdir release c.进入该release文件夹。输入指令：cd release d.编译。输入命令：（最后在local接着的是两个点，不要忘了，最后直接复制粘贴进命令行）会比较耗时，比如会花费20分钟来编译，会有进度显示哒。cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. e.开启线程(按照自己的配置,处理器核数*2)。输入命令： make -j4 f.sudo make install （这一步也很快） opencv大致安装完毕，但还没结束哦。接下来就是要配置环境啦！不然还是没法用opencv的哦！ a.在文件/etc/ld.so.conf中添加 /usr/local/lib (这里就是上文中您的安装目录下的) b.当我们打开、/etc/ld.so.conf文件时，发现它的属性为只读，则终端上输入以下命令： sudo chmod 666 /etc/ld.so.conf 改变文件属性为允许所有用户对该文件进行读写操作然后另起一行输入/usr/local/lib了。 c.完成动态库的共享。请输入 sudo ldconfig –v接下来，配置opencv的头文件位置！ a.输入命令： sudo gedit /etc/bash.bashrc 进入编辑页面。 b.在编辑命令输入以下内容：PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig 并保存下来。 c.终端输入命令：export PKG_CONFIG_PATH d.使配置生效。终端输入命令:sudo source /etc/bash.bashrc 的 e.由于source为root命令，需要root权限。输入命令：su bruce（bruce为我本人的用户名，请换成您自己的）然后按提示进行。 f.再次使配置生效。终端输入命令： source /etc/bash.bashrc g.退出。终端输入命令：quit()或者直接键盘按住 Ctrl+D 这两个按键。 h.更新database。终端输入命令： sudo updatedb 选择一个demo进行测试。完工啦！！！哈哈，最后就可以来测试我们是否搞定这个opencv的配置啦 a.在解压的opencv目录下找到 samples/c/文件夹。在该文件夹下输入终端指令： ./build_all.sh (这一步将会花费大概1分钟左右时间编译) b.编译完成后，选一个运行，比如 find_obj 程序。该文件夹下终端输入： ./ find_obj 嘻嘻，一两秒内有看到图片了吧 python与opencv的接口配置。ubuntu16.04自带python2.7和python3.5。在安装完Opencv后，我们安装Python-opencv，请在终端输入命令 ： sudo apt-get install python-opencv也可以安装python-numpy ： sudo apt-get install python-numpy终端输入： cd ~ 进入根目录。再输入python 回车键后，显示python的版本信息，最后输入import cv ,如果没有弹出任何信息，说明接口配置成功。 参考资料：【1】 https://blog.csdn.net/maxujian3893/article/details/64125988【2】 https://blog.csdn.net/u011557212/article/details/54706966?utm_source=itdadao&amp;utm_medium=referral p.s. 相关问题。打开 vi 可以，不过应该是乱码。直接运行吧比如说 你写了一个 c程序 helloworld.c你用命令gcc -o helloworld.o helloworld.c就会生成一个可执行的文件 helloworld.o用命令 ./helloworld.o就可以执行了（注意 点斜杠 是运行，有一点的） – 嘿嘿，偷懒了，部分步骤图我还没有添加上来，等过几天闲下来了再加上来！！]]></content>
      <categories>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu，opencv，安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[face2ai社区成立啦！]]></title>
    <url>%2Fface2%E7%A4%BE%E5%8C%BA%E6%88%90%E7%AB%8B%E5%95%A6%2F</url>
    <content type="text"><![CDATA[categories: 人工智能平台tags: [社区平台建设, 人工智能] 欢迎各位！共同成长进步！ 人工智能基础links：https://www.face2ai.com/欢迎来访！]]></content>
      <categories>
        <category>人工智能平台</category>
      </categories>
      <tags>
        <tag>社区平台建设</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李文学分析戴诗琪同学的《基于深度学习的疲劳驾驶检测算法》]]></title>
    <url>%2F0_%E6%88%B4%E8%AF%97%E7%90%AA_%E5%9F%BA%E4%BA%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%96%B2%E5%8A%B3%E9%A9%BE%E9%A9%B6%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关键词：HOG算子；特征点模型；深度学习；CNN；疲劳检测算法Question：查看作者的相关思路；查看作者是否有相关的数据支撑 摘要：针对现有疲劳驾驶检测算法，实用性差或者准确率低的问题，本文提出了一种基于深度学习的疲劳驾驶检测算法。 首先，使用HOG（Histogram of Oriented Gradient）特征算子检测人脸的存在；其次，利用特征点模型实现人脸的对齐，同时实现眼睛、嘴巴的分割。 最后，通过深度卷积神经网络提取驾驶员的眼部疲劳特征，并融合驾驶员嘴部的疲劳特征进行疲劳预警。 大量的实验表明，该方法在疲劳驾驶检测的准确率、实时性等方面都取得明显的性能提升。 本文说，使用深度网络直接从图像中学习学习视觉特征表示，相较于手工设计的特征，对光照、姿势等条件变化，具有更好的鲁棒性。以上的疲劳驾驶检测算法都取得了一定的效果与进展，但仍然存在很大的局限性：基于行为特征的检测算法不需要驾驶人直接接触检测装置，并且在汽车现有装置的基础上对设备需求较低，实用性很强，易于推广，但会受到驾驶人个人习惯、路面条件和车辆型号的限制，所以效果不是很好。 但是，本文所说的，利用深度学习方法提取眼睛部位的视觉特征，建立视觉模型，以提升视觉特征的辨别能力，然后采用PERCLOS算法结合打哈欠的频率，判断驾驶员是否疲劳，减少单一特征的误检率。实验结果表明，本文提出的基于深度学习的疲劳驾驶检测方法是有效的 基于深度学习的疲劳驾驶检测本文设计的算法分为4步： 首先利用HOG特征模型检测初摄像头实时获取的画面中的驾驶员的人脸图像， 然后根据面部标识算法，定位出人眼和嘴部区域 接着将定位出的眼睛区域图像输入深度卷积神经网络提取眼睛的视觉特征并分别判断眼睛和嘴巴的开闭程度， 最后根据PERCLOS算法求出单位时间内眼睛闭和状态所占的百分比，同时结合打哈欠的频率完成疲劳驾驶预警机制。 基于HOG的人脸检测HOG特征具有较好的光学不变性与集合不变性，尤其适用于目标检测。主要步骤如下：（1）、归一化（2）、遍历图像，计算梯度值和梯度方向（3）、得到梯度方向直方图（4）、合并后得到特征向量并归一化（5）、得到最终的HOG特征向量，描述整个图像。 本文选用的单元区域大小为88像素，单位块的大小为16像素，滑动步长L为8。输入图像大小为128128时，则生成的HOG特征向量为8100维。最后通过提取大量的已标定人脸样本的HOG特征，并使用SVM对其进行训练生成人来鸟检测器。具体训练算法如表 算法一 所示。&lt;&gt; 人脸特征点定位本文使用2014年Kazemi和Sullivan提出的面部标志估算算法检测人脸特征点并对齐人脸。首先选取人脸的68个特殊标志点模型，从眉毛外沿至下颌底部，包括眼睛轮廓和嘴部轮廓等。利用该算法提出的基于梯度增强的框架，通过优化损失函数和误差的总和来学习回归树集合（Ensemble of Regression Trees，ERT），检测出脸部图像中的68个关键点，最后对齐人脸，并根据关键点序号定位出所需要的眼部、嘴部图像。 卷积神经网络识别眼部状态在定位眼睛和嘴部区域后，分割上述局部区域，然后建立眼睛的诗句特征模型。传统的基于深度学习的目标识别方法，主要针对单张的静态图片，使用CNN网络提取特征，将某一中间层作为特征描述然后利用softmax等分类器对其分类，中间层的特征描述通常位数较高。而在疲劳驾驶检测过程中需要对视频监控的连续多幅图像进行处理，包含了更多的光照、遮挡等条件变化信息。本文没有采用传统的损失函数而是采用基于三元组损失函数的深度卷积神经网络学习眼睛特征。传统的损失函数，主要是计算最小化预测标记与真实标记之间的误差，它虽然可以保障类间分离，但不能实现类内聚集。三元组损失函数，计算最大化不同类对象之间的欧式距离与同类对象之间的欧式距离的差值，这可以保障类间距离最大化，类内距离最小化，实现深度学习网络类内聚集、类间原理，提高了深度网络的分类能力。区分睁眼和闭眼两个状态集合，将独立的样本分类任务转换为样本间的距离度量学习任务，保留了更多的数据内部的关联性信息，直接通过两幅图像特征的欧式距离来判断两幅图像世博来同一类别，去除使用中间层作为特征描述的间接性实现端到端的学习，啊降低计算量，提高系统的实时性，网络结构如图5所示。 如图，CNN结构的输入尺寸大小为4848，输出层为2维向量，表示2个类别（眼睛闭合和眼睛睁开），中间包含四个阶段的卷积层、归一化层、池化层的操作。第一阶段的卷积核大小分别为33和11，池化层以33的大小平均池化对比归一化的特征图，后续阶段的相应操作与第一阶段类似。 而一个三元组，包含3个样本：一个随机选择的眼睛样本Anchor,一个与随机样本相似的样本Positive，一个与随机样本不相似的样本Negative，核心思想为通过学习是的随机样本与相似样本间的距离相差最小，与不相似样本间的距离相差最大。也可以得到其损失函数。三元组分类损失对三个样本特征的梯度，可以得到。最后，我们使用随机梯度下降算法训练上面描述的基于三元组损失深度卷积神经网络模型，具体u想你连算法如下图。【伪代码】 利用深度卷积神经网络判别单帧图像的眼部开闭状态后，根据PRECCLOS定义计算单位时间内闭合状态所占时间的百分比。 嘴部状态识别在驾驶过程中，驾驶员的嘴部通常由闭合、说话或唱歌、打哈欠三种状态，打哈欠的状态下，嘴部的张开程度将明显并持续大于前两种状态，因此在嘴部定位精确的情况下，可直接根据嘴部图像的宽高比判断嘴巴的行开程度，快速区分这三种状态，减少计算量。具体步骤如下： 宽高比小于某一个阈值T时，可判断当前图像帧为打哈欠 当打哈欠的视频帧连续达到K帧时，记作打哈欠一次。 分别判断眼部和嘴部的疲劳状态后，融合眼睛的疲劳参数与嘴部的疲劳参数，分别赋予一定的权重，可以得到最终的疲劳值。 实验结果与分析数据集与网络训练本文采用了ZJU眨眼视频数据集和CEW眼睛数据集,ZJU包含20个人的80个avi剪辑视频，每个人包含四类片段：【正面视图未带眼睛、正面视图薄边框眼睛、正面视图黑框眼镜、向上视角未戴眼镜】在眨眼过程中，手动选择眼睛睁开、半开半闭、闭合的眼睛图像，并将左右眼分开存储，共产生7334幅图像（1574张闭眼样本和5770张睁眼样本）；CEW包含2423幅人脸图像，同样上述操作。 将所有样本图像归一化为48*48，分别合并睁眼、闭眼样本集（不区分左右眼），然后分别从中划分20%的样本作为测试机，其余为训练集。使用随机选择策略在训练集中生成1000组三元组用于网络迭代训练，【本实验Ubuntu环境下使用touch框架实现】。 实验结果眼睛状态识别测试 睁眼和闭眼的正确数目及识别准确率。 利用传统的CNN方法，在相同测试集上的测试结果 本文方法和CNN方法，眼睛状态识别的对比（测试项目如下：准确率，人脸检测时间，嘴部眼睛定位时间，眼部识别时间） 疲劳状态识别测试 训练集：采用的YawDD的数据集，包含了不同性别、种族、光照环境。测试集：3个测试者（男性，女性，带眼镜男性） 总结疲劳特征的选择是疲劳驾驶检测的关键, 本文提出了一种基于深度学习的疲劳驾驶检测方法. 该方法首先利用 HOG 特征检测视频中的人脸图像, 然后利用特征点模型实现人脸器官的定位和分割, 接着使用深度卷积神经网络学习眼睛区域的特征并实现眼睛闭合状态的识别, 最后融合眼睛闭合状态与嘴部闭合状态实现疲劳驾驶检测预警. 与其它的疲劳驾驶检测方法相比, 该方法无需接触驾驶员, 能够自主提取更有判别力的眼部特征, 并且具有良好的实时性, 特征的融合也进一步提高了准确性. 在 ZJU、CEW 和 YawDD 数据集上与 CNN 的视觉特征的检测方法的对比试验和分析结果表明, 该方法具有更好的检测性能.]]></content>
      <categories>
        <category>-毕业论文</category>
      </categories>
      <tags>
        <tag>-毕业论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的新生活]]></title>
    <url>%2F%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B%E6%96%B0%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[categories: 生活tags: [生活， 自己] 这是前言 -- 这个时候，就此开始吧。。]]></content>
      <categories>
        <category>-生活</category>
      </categories>
      <tags>
        <tag>-生活 -自己</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[梦]]></title>
    <url>%2F%E6%A2%A6%2F</url>
    <content type="text"><![CDATA[categories: 生活tags: [梦， 自己] 这是前言 跑快点，不然没命了要泄洪。我，姐，另一个身材不错的小姐姐，三个人在沟壑边上的小路上，往前面探视。 路上，半人多高青绿青绿的杂草，在肆意的摇摆，似乎毫不畏惧那汹涌不定的洪峰，仿佛淹没之后，迎接他们的仍是新生。 今天我要说的故事，其实很短，当一行三人走到石桥下沿 似乎再也不能沿着河道下行的时候，我们仨站住了，小心翼翼却又颇具胆量的往河道下眺望，仿佛那湍急的水流、溅起来的浪花是我们小时候玩的极熟的玩伴似的————丝毫不会对你产生致命的威胁。 果然，水下浪花带来的水雾让人全身清爽，涛涛水声带来的震撼，十分立体！我们一边惊喜刺激，一边小心翼翼————我们知道，掉下去，九死一生都不为过。 可能自小机灵的我这时候受到了上天的感化，不小心往上游瞄了一眼！意外！！！几人高的巨浪奔涌而下，像一只巨龙，仿佛要吞噬这道上的一切，绝无商量的可能性！“往后退！！！快！”，我的一声惊吼，让她两懵了一下，所以我立刻拉着她两往后退！万幸，背后是一条刻进去的小道，让我们得以稍事休息，看不到那河道上方拐角的巨浪！！！ 不知道为什么，鬼使神差的我探出小道往上游看，一看吓一跳！！似乎更大的洪峰就要到来，隐隐约约我感受到，应该是传说中泄洪般的巨浪就要来临了。。。。。我们，只有短短十秒左右时间逃离这里，这个可能埋没我们三个年轻生命的地方！ 我去年马拉松，现在从这个小道， 跑到上游10米左右的小道，才有生还的可能（那个小道能够出去。。。的可能性比较大，因为暂时的这个小道，是死的，继续呆下去只会被水浪浸没并冲击而死）。。她两没练习过跑步，短跑冲刺才有戏，她们能行吗！！？？？才10秒钟，快跑！！！于是，2秒钟说完立刻行动！！！死，似乎没那么可怕了，因为，它终将在8秒后来临，不死，才是奇迹。。。。 这时候的水浪，似乎还是那么的汹涌，可，还是那么美丽吗？ 如果时间到没跑过去，只能双手抓住杂草，等待10秒后下一个洪峰到来前，继续奔跑！我能撑过这一个洪峰吗，，，，心里没底（即使我健身房锻炼了半年，近期我在锻炼肩部和肱三头肌。。。。） 啊，我的双臂能承受住吗！！两个妹子我已经管不了了！！！我的手啊！！疼！ 啊，醒了。。。。原来双手受冻，冷醒了。。。心，扑通扑通，，活着真好。。呵 参考链接： 《平凡的世界》里，村里要炸山，却突然跑进爆炸区一个愣子， 最后似乎被炸死了 8月底去了宜昌三峡，气势磅礴，于是联想到当初修建时可能出现的场景————奔流大浪！ 几年前去松滋水电站，看到的泄洪画面。]]></content>
      <categories>
        <category>-生活</category>
      </categories>
      <tags>
        <tag>-生活 -梦</tag>
      </tags>
  </entry>
</search>
